from auto_lens.analysis import non_linear
from auto_lens.analysis import model_mapper as mm
from auto_lens.analysis import fitting
from auto_lens.imaging import grids
from auto_lens.analysis import ray_tracing
import logging

# TODO: Pipelines that modify images, pipeline with or without hyper_image, pipeline with prior modification

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)
logger.level = logging.DEBUG


class Analysis(object):
    def __init__(self, model_mapper, non_linear_optimizer=None,
                 fitting_function=fitting.likelihood_for_image_tracer_pixelization_and_instrumentation,
                 lens_galaxy_priors=None, source_galaxy_priors=None, pixelization_class=None,
                 instrumentation_class=None):
        """
        A generic analysis class. Model classes are provided in the constructor as keyword arguments. These classes act
        as variables. Each fitting in the analysis will use a new set of model instances generated by these classes.

        Any model instance required in the analysis that does not have a model class passed in the constructor must
        be passed into the run argument.

        Parameters
        ----------
        model_mapper: ModelMapper
            A class used to bridge between non linear unit vectors and class instances
        non_linear_optimizer: NonLinearOptimizer
            A wrapper around a library that searches an n-dimensional space by providing unit vector hypercubes to
            the analysis.
        lens_galaxy_priors
        source_galaxy_priors
        pixelization_class
        instrumentation_class
            The optional model classes that produce variable model instances to be used in each fitting

        Examples
        --------
        # We create an analysis which will be used to try out different attributes for a lens galaxy
        analysis = Analysis(lens_galaxy_priors=[galaxy_prior])

        # Now when we run the analysis we have to pass in source galaxies, pixelization and instrumentation. These will
        # remain constant throughout the analysis.
        result = analysis.run(image=image, source_galaxies=[source_galaxy], mask=mask,
                              pixelization=pixelization, instrumentation=instrumentation)
        """
        self.model_mapper = model_mapper
        self.non_linear_optimizer = non_linear_optimizer if non_linear_optimizer is not None else non_linear.MultiNest(
            model_mapper)
        self.fitting_function = fitting_function
        self.included_attributes = []

        self.lens_galaxy_priors = lens_galaxy_priors
        self.source_galaxy_priors = source_galaxy_priors
        self.pixelization_class = pixelization_class
        self.instrumentation_class = instrumentation_class

        # TODO: This may be better in pipeline?
        if pixelization_class is not None:
            model_mapper.add_class('pixelization', pixelization_class)

        if instrumentation_class is not None:
            model_mapper.add_class('instrumentation', instrumentation_class)

    def run(self, image, mask, **kwargs):
        """
        Runs the analysis. Any model classes corresponding to model instances required in the analysis that were not
        passed into the constructor must be passed in here as keyword arguments.

        Parameters
        ----------
        image: Image
            An image to fit for
        mask: Mask
            A mask describing the region of the image we are going to analyse
        kwargs
            The model instances that are to remain constant throughout this analysis

        Returns
        -------
        result: Result
            An object comprising the final model instances generated and a corresponding likelihood
        """
        image_grid_collection = grids.GridCoordsCollection.from_mask(mask)

        # TODO : For multinest, the fitness function returns a likelihood. For the Downhill Simplex, it returns a
        # TODO : chi squared (-2.0 * likelihood) - this seemed like the best place to add the clause in.
        # TODO : This is currently untested.

        if type(self.non_linear_optimizer) is non_linear.DownhillSimplex:
            return_chi_squared = True
        else:
            return_chi_squared = False

        run = Analysis.Run(image, image_grid_collection, self.model_mapper, self.fitting_function, return_chi_squared)

        kwargs.update(self.__dict__)

        for key, value in kwargs.items():
            setattr(run, key, value)

        self.non_linear_optimizer.run(run.fitness_function)

        return self.__class__.Result(run)

    class Result(object):
        def __init__(self, run):
            """
            An object comprising the final model instances generated and a corresponding likelihood

            Parameters
            ----------
            run: Run
                A run object created when the analysis is run
            """
            for name in ['pixelization', 'instrumentation', 'lens_galaxies', 'source_galaxies']:
                setattr(self, name, getattr(run, name))

            self.likelihood = run.likelihood

    class Run(object):
        def __init__(self, image, image_grid_collection, model_mapper, fitting_function, return_chi_squared=False):
            """
            An object created when the analysis is run. Model class and model instance arguments are set by the analysis

            Parameters
            ----------
            image: Image
                An image to be analysed
            image_grid_collection: GridCoordinateCollection
                An object storing grids used to map between the image and arrays used in the analysis
            model_mapper: ModelMapper
                A class used to bridge between non linear unit vectors and class instances
            return_chi_squared : bool
                Whether the fitness function returns a likelihood (default, false) or a chi_squared value.
            """
            self.image = image
            self.image_grid_collection = image_grid_collection
            self.model_mapper = model_mapper
            self.fitting_function = fitting_function
            self.return_chi_squared = return_chi_squared

        # noinspection PyAttributeOutsideInit,PyUnresolvedReferences
        def fitness_function(self, physical_values):
            """
            A function that constructs model instances and determines a likelihood

            Parameters
            ----------
            physical_values: [float]
                A vector of physical values from a non-linear search

            Returns
            -------
            likelihood: float
                The likelihood that this model instance fits the image
            """

            model_instance = self.model_mapper.instance_from_physical_vector(physical_values)

            if hasattr(model_instance, 'pixelization'):
                self.pixelization = model_instance.pixelization
            if hasattr(model_instance, "instrumentation"):
                self.instrumentation = model_instance.instrumentation
            if self.lens_galaxy_priors is not None:
                self.lens_galaxies = list(
                    map(lambda galaxy_prior: galaxy_prior.galaxy_for_model_instance(model_instance),
                        self.lens_galaxy_priors))
            if self.source_galaxy_priors is not None:
                self.source_galaxies = list(
                    map(lambda galaxy_prior: galaxy_prior.galaxy_for_model_instance(model_instance),
                        self.source_galaxy_priors))

            # Construct a ray tracer
            tracer = ray_tracing.Tracer(self.lens_galaxies, self.source_galaxies, self.image_grid_collection)
            # Determine likelihood:
            self.likelihood = self.fitting_function(self.image,
                                                    tracer,
                                                    self.pixelization,
                                                    self.instrumentation)

            if self.return_chi_squared is True:
                self.likelihood = -2.0 * self.likelihood

            return self.likelihood


class ModelAnalysis(Analysis):
    def __init__(self, lens_galaxy_priors, source_galaxy_priors, model_mapper=mm.ModelMapper(),
                 non_linear_optimizer=None):
        """
        A class encapsulating an analysis. An analysis takes an image and a set of galaxy priors describing an
        assumed model and applies a pixelization and non linear optimizer to find the best possible fit between the
        image and model.

        Parameters
        ----------
        lens_galaxy_priors: [GalaxyPrior]
            A list of prior instances describing the lens
        source_galaxy_priors: [GalaxyPrior]
            A list of prior instances describing the source
        model_mapper: ModelMapper
            A class used to bridge between non linear unit vectors and class instances
        non_linear_optimizer: NonLinearOptimizer
            A wrapper around a library that searches an n-dimensional space by providing unit vector hypercubes to
            the analysis.
        """

        super().__init__(model_mapper=model_mapper, non_linear_optimizer=non_linear_optimizer,
                         lens_galaxy_priors=lens_galaxy_priors, source_galaxy_priors=source_galaxy_priors)


class HyperparameterAnalysis(Analysis):
    def __init__(self, pixelization_class, instrumentation_class, model_mapper=mm.ModelMapper(),
                 non_linear_optimizer=None):
        """
        An analysis to improve hyperparameter settings. This optimizes pixelization and instrumentation.

        Parameters
        ----------
        pixelization_class: Pixelization
            A class describing how the source plane should be pixelized
        instrumentation_class: Instrumentation
            A class describing instrumental effects
        model_mapper: ModelMapper
            A class used to bridge between non linear unit vectors and class instances
        non_linear_optimizer: NonLinearOptimizer
            A wrapper around a library that searches an n-dimensional space by providing unit vector hypercubes to
            the analysis.
        """
        super().__init__(model_mapper, non_linear_optimizer, pixelization_class=pixelization_class,
                         instrumentation_class=instrumentation_class)
